# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 2.5.1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class LogicalSwitch(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'system_owned': 'bool',
        'display_name': 'str',
        'description': 'str',
        'tags': 'list[Tag]',
        'create_user': 'str',
        'protection': 'str',
        'create_time': 'int',
        'last_modified_time': 'int',
        'last_modified_user': 'str',
        'id': 'str',
        'resource_type': 'str',
        'switch_type': 'str',
        'replication_mode': 'str',
        'extra_configs': 'list[ExtraConfig]',
        'uplink_teaming_policy_name': 'str',
        'transport_zone_id': 'str',
        'ip_pool_id': 'str',
        'vlan': 'int',
        'hybrid': 'bool',
        'mac_pool_id': 'str',
        'vni': 'int',
        'vlan_trunk_spec': 'VlanTrunkSpec',
        'admin_state': 'str',
        'address_bindings': 'list[PacketAddressClassifier]',
        'switching_profile_ids': 'list[SwitchingProfileTypeIdEntry]'
    }
    if hasattr(ManagedResource, "swagger_types"):
        swagger_types.update(ManagedResource.swagger_types)

    attribute_map = {
        'system_owned': '_system_owned',
        'display_name': 'display_name',
        'description': 'description',
        'tags': 'tags',
        'create_user': '_create_user',
        'protection': '_protection',
        'create_time': '_create_time',
        'last_modified_time': '_last_modified_time',
        'last_modified_user': '_last_modified_user',
        'id': 'id',
        'resource_type': 'resource_type',
        'switch_type': 'switch_type',
        'replication_mode': 'replication_mode',
        'extra_configs': 'extra_configs',
        'uplink_teaming_policy_name': 'uplink_teaming_policy_name',
        'transport_zone_id': 'transport_zone_id',
        'ip_pool_id': 'ip_pool_id',
        'vlan': 'vlan',
        'hybrid': 'hybrid',
        'mac_pool_id': 'mac_pool_id',
        'vni': 'vni',
        'vlan_trunk_spec': 'vlan_trunk_spec',
        'admin_state': 'admin_state',
        'address_bindings': 'address_bindings',
        'switching_profile_ids': 'switching_profile_ids'
    }
    if hasattr(ManagedResource, "attribute_map"):
        attribute_map.update(ManagedResource.attribute_map)

    def __init__(self, system_owned=None, display_name=None, description=None, tags=None, create_user=None, protection=None, create_time=None, last_modified_time=None, last_modified_user=None, id=None, resource_type=None, switch_type=None, replication_mode=None, extra_configs=None, uplink_teaming_policy_name=None, transport_zone_id=None, ip_pool_id=None, vlan=None, hybrid=False, mac_pool_id=None, vni=None, vlan_trunk_spec=None, admin_state=None, address_bindings=None, switching_profile_ids=None, *args, **kwargs):  # noqa: E501
        """LogicalSwitch - a model defined in Swagger"""  # noqa: E501
        self._system_owned = None
        self._display_name = None
        self._description = None
        self._tags = None
        self._create_user = None
        self._protection = None
        self._create_time = None
        self._last_modified_time = None
        self._last_modified_user = None
        self._id = None
        self._resource_type = None
        self._switch_type = None
        self._replication_mode = None
        self._extra_configs = None
        self._uplink_teaming_policy_name = None
        self._transport_zone_id = None
        self._ip_pool_id = None
        self._vlan = None
        self._hybrid = None
        self._mac_pool_id = None
        self._vni = None
        self._vlan_trunk_spec = None
        self._admin_state = None
        self._address_bindings = None
        self._switching_profile_ids = None
        self.discriminator = None
        if system_owned is not None:
            self.system_owned = system_owned
        if display_name is not None:
            self.display_name = display_name
        if description is not None:
            self.description = description
        if tags is not None:
            self.tags = tags
        if create_user is not None:
            self.create_user = create_user
        if protection is not None:
            self.protection = protection
        if create_time is not None:
            self.create_time = create_time
        if last_modified_time is not None:
            self.last_modified_time = last_modified_time
        if last_modified_user is not None:
            self.last_modified_user = last_modified_user
        if id is not None:
            self.id = id
        if resource_type is not None:
            self.resource_type = resource_type
        if switch_type is not None:
            self.switch_type = switch_type
        if replication_mode is not None:
            self.replication_mode = replication_mode
        if extra_configs is not None:
            self.extra_configs = extra_configs
        if uplink_teaming_policy_name is not None:
            self.uplink_teaming_policy_name = uplink_teaming_policy_name
        self.transport_zone_id = transport_zone_id
        if ip_pool_id is not None:
            self.ip_pool_id = ip_pool_id
        if vlan is not None:
            self.vlan = vlan
        if hybrid is not None:
            self.hybrid = hybrid
        if mac_pool_id is not None:
            self.mac_pool_id = mac_pool_id
        if vni is not None:
            self.vni = vni
        if vlan_trunk_spec is not None:
            self.vlan_trunk_spec = vlan_trunk_spec
        self.admin_state = admin_state
        if address_bindings is not None:
            self.address_bindings = address_bindings
        if switching_profile_ids is not None:
            self.switching_profile_ids = switching_profile_ids
        ManagedResource.__init__(self, *args, **kwargs)

    @property
    def system_owned(self):
        """Gets the system_owned of this LogicalSwitch.  # noqa: E501

        Indicates system owned resource  # noqa: E501

        :return: The system_owned of this LogicalSwitch.  # noqa: E501
        :rtype: bool
        """
        return self._system_owned

    @system_owned.setter
    def system_owned(self, system_owned):
        """Sets the system_owned of this LogicalSwitch.

        Indicates system owned resource  # noqa: E501

        :param system_owned: The system_owned of this LogicalSwitch.  # noqa: E501
        :type: bool
        """

        self._system_owned = system_owned

    @property
    def display_name(self):
        """Gets the display_name of this LogicalSwitch.  # noqa: E501

        Defaults to ID if not set  # noqa: E501

        :return: The display_name of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._display_name

    @display_name.setter
    def display_name(self, display_name):
        """Sets the display_name of this LogicalSwitch.

        Defaults to ID if not set  # noqa: E501

        :param display_name: The display_name of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._display_name = display_name

    @property
    def description(self):
        """Gets the description of this LogicalSwitch.  # noqa: E501

        Description of this resource  # noqa: E501

        :return: The description of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this LogicalSwitch.

        Description of this resource  # noqa: E501

        :param description: The description of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._description = description

    @property
    def tags(self):
        """Gets the tags of this LogicalSwitch.  # noqa: E501

        Opaque identifiers meaningful to the API user  # noqa: E501

        :return: The tags of this LogicalSwitch.  # noqa: E501
        :rtype: list[Tag]
        """
        return self._tags

    @tags.setter
    def tags(self, tags):
        """Sets the tags of this LogicalSwitch.

        Opaque identifiers meaningful to the API user  # noqa: E501

        :param tags: The tags of this LogicalSwitch.  # noqa: E501
        :type: list[Tag]
        """

        self._tags = tags

    @property
    def create_user(self):
        """Gets the create_user of this LogicalSwitch.  # noqa: E501

        ID of the user who created this resource  # noqa: E501

        :return: The create_user of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._create_user

    @create_user.setter
    def create_user(self, create_user):
        """Sets the create_user of this LogicalSwitch.

        ID of the user who created this resource  # noqa: E501

        :param create_user: The create_user of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._create_user = create_user

    @property
    def protection(self):
        """Gets the protection of this LogicalSwitch.  # noqa: E501

        Protection status is one of the following: PROTECTED - the client who retrieved the entity is not allowed             to modify it. NOT_PROTECTED - the client who retrieved the entity is allowed                 to modify it REQUIRE_OVERRIDE - the client who retrieved the entity is a super                    user and can modify it, but only when providing                    the request header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be determined for this           entity.   # noqa: E501

        :return: The protection of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._protection

    @protection.setter
    def protection(self, protection):
        """Sets the protection of this LogicalSwitch.

        Protection status is one of the following: PROTECTED - the client who retrieved the entity is not allowed             to modify it. NOT_PROTECTED - the client who retrieved the entity is allowed                 to modify it REQUIRE_OVERRIDE - the client who retrieved the entity is a super                    user and can modify it, but only when providing                    the request header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be determined for this           entity.   # noqa: E501

        :param protection: The protection of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._protection = protection

    @property
    def create_time(self):
        """Gets the create_time of this LogicalSwitch.  # noqa: E501

        Timestamp of resource creation  # noqa: E501

        :return: The create_time of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._create_time

    @create_time.setter
    def create_time(self, create_time):
        """Sets the create_time of this LogicalSwitch.

        Timestamp of resource creation  # noqa: E501

        :param create_time: The create_time of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._create_time = create_time

    @property
    def last_modified_time(self):
        """Gets the last_modified_time of this LogicalSwitch.  # noqa: E501

        Timestamp of last modification  # noqa: E501

        :return: The last_modified_time of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._last_modified_time

    @last_modified_time.setter
    def last_modified_time(self, last_modified_time):
        """Sets the last_modified_time of this LogicalSwitch.

        Timestamp of last modification  # noqa: E501

        :param last_modified_time: The last_modified_time of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._last_modified_time = last_modified_time

    @property
    def last_modified_user(self):
        """Gets the last_modified_user of this LogicalSwitch.  # noqa: E501

        ID of the user who last modified this resource  # noqa: E501

        :return: The last_modified_user of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._last_modified_user

    @last_modified_user.setter
    def last_modified_user(self, last_modified_user):
        """Sets the last_modified_user of this LogicalSwitch.

        ID of the user who last modified this resource  # noqa: E501

        :param last_modified_user: The last_modified_user of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._last_modified_user = last_modified_user

    @property
    def id(self):
        """Gets the id of this LogicalSwitch.  # noqa: E501

        Unique identifier of this resource  # noqa: E501

        :return: The id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this LogicalSwitch.

        Unique identifier of this resource  # noqa: E501

        :param id: The id of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._id = id

    @property
    def resource_type(self):
        """Gets the resource_type of this LogicalSwitch.  # noqa: E501

        The type of this resource.  # noqa: E501

        :return: The resource_type of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._resource_type

    @resource_type.setter
    def resource_type(self, resource_type):
        """Sets the resource_type of this LogicalSwitch.

        The type of this resource.  # noqa: E501

        :param resource_type: The resource_type of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._resource_type = resource_type

    @property
    def switch_type(self):
        """Gets the switch_type of this LogicalSwitch.  # noqa: E501

        This field indicates purpose of a LogicalSwitch. It is set by manager internally or user can provide this field. If not set, DEFAULT type is assigned. NSX components can use this field to create LogicalSwitch that provides component specific functionality. DEFAULT type LogicalSwitches are created for basic L2 connectivity by API users. SERVICE_PLANE type LogicalSwitches are system created service plane LogicalSwitches for Service Insertion service. User can not create SERVICE_PLANE type of LogicalSwitch. DHCP_RELAY type LogicalSwitches are created by external user like Policy with special permissions or by system and will be treated as internal LogicalSwitches. Such LogicalSwitch will not be exposed to vSphere user.   # noqa: E501

        :return: The switch_type of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._switch_type

    @switch_type.setter
    def switch_type(self, switch_type):
        """Sets the switch_type of this LogicalSwitch.

        This field indicates purpose of a LogicalSwitch. It is set by manager internally or user can provide this field. If not set, DEFAULT type is assigned. NSX components can use this field to create LogicalSwitch that provides component specific functionality. DEFAULT type LogicalSwitches are created for basic L2 connectivity by API users. SERVICE_PLANE type LogicalSwitches are system created service plane LogicalSwitches for Service Insertion service. User can not create SERVICE_PLANE type of LogicalSwitch. DHCP_RELAY type LogicalSwitches are created by external user like Policy with special permissions or by system and will be treated as internal LogicalSwitches. Such LogicalSwitch will not be exposed to vSphere user.   # noqa: E501

        :param switch_type: The switch_type of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        allowed_values = ["DEFAULT", "SERVICE_PLANE", "DHCP_RELAY"]  # noqa: E501
        if switch_type not in allowed_values:
            raise ValueError(
                "Invalid value for `switch_type` ({0}), must be one of {1}"  # noqa: E501
                .format(switch_type, allowed_values)
            )

        self._switch_type = switch_type

    @property
    def replication_mode(self):
        """Gets the replication_mode of this LogicalSwitch.  # noqa: E501

        Replication mode of the Logical Switch  # noqa: E501

        :return: The replication_mode of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._replication_mode

    @replication_mode.setter
    def replication_mode(self, replication_mode):
        """Sets the replication_mode of this LogicalSwitch.

        Replication mode of the Logical Switch  # noqa: E501

        :param replication_mode: The replication_mode of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        allowed_values = ["MTEP", "SOURCE"]  # noqa: E501
        if replication_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `replication_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(replication_mode, allowed_values)
            )

        self._replication_mode = replication_mode

    @property
    def extra_configs(self):
        """Gets the extra_configs of this LogicalSwitch.  # noqa: E501

        This property could be used for vendor specific configuration in key value string pairs, the setting in extra_configs will be automatically inheritted by logical ports in the logical switch.   # noqa: E501

        :return: The extra_configs of this LogicalSwitch.  # noqa: E501
        :rtype: list[ExtraConfig]
        """
        return self._extra_configs

    @extra_configs.setter
    def extra_configs(self, extra_configs):
        """Sets the extra_configs of this LogicalSwitch.

        This property could be used for vendor specific configuration in key value string pairs, the setting in extra_configs will be automatically inheritted by logical ports in the logical switch.   # noqa: E501

        :param extra_configs: The extra_configs of this LogicalSwitch.  # noqa: E501
        :type: list[ExtraConfig]
        """

        self._extra_configs = extra_configs

    @property
    def uplink_teaming_policy_name(self):
        """Gets the uplink_teaming_policy_name of this LogicalSwitch.  # noqa: E501

        This name has to be one of the switching uplink teaming policy names listed inside the logical switch's TransportZone. If this field is not specified, the logical switch will not have a teaming policy associated with it and the host switch's default teaming policy will be used.  # noqa: E501

        :return: The uplink_teaming_policy_name of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._uplink_teaming_policy_name

    @uplink_teaming_policy_name.setter
    def uplink_teaming_policy_name(self, uplink_teaming_policy_name):
        """Sets the uplink_teaming_policy_name of this LogicalSwitch.

        This name has to be one of the switching uplink teaming policy names listed inside the logical switch's TransportZone. If this field is not specified, the logical switch will not have a teaming policy associated with it and the host switch's default teaming policy will be used.  # noqa: E501

        :param uplink_teaming_policy_name: The uplink_teaming_policy_name of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._uplink_teaming_policy_name = uplink_teaming_policy_name

    @property
    def transport_zone_id(self):
        """Gets the transport_zone_id of this LogicalSwitch.  # noqa: E501

        Id of the TransportZone to which this LogicalSwitch is associated  # noqa: E501

        :return: The transport_zone_id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._transport_zone_id

    @transport_zone_id.setter
    def transport_zone_id(self, transport_zone_id):
        """Sets the transport_zone_id of this LogicalSwitch.

        Id of the TransportZone to which this LogicalSwitch is associated  # noqa: E501

        :param transport_zone_id: The transport_zone_id of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        if transport_zone_id is None:
            raise ValueError("Invalid value for `transport_zone_id`, must not be `None`")  # noqa: E501

        self._transport_zone_id = transport_zone_id

    @property
    def ip_pool_id(self):
        """Gets the ip_pool_id of this LogicalSwitch.  # noqa: E501

        IP pool id that associated with a LogicalSwitch.  # noqa: E501

        :return: The ip_pool_id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._ip_pool_id

    @ip_pool_id.setter
    def ip_pool_id(self, ip_pool_id):
        """Sets the ip_pool_id of this LogicalSwitch.

        IP pool id that associated with a LogicalSwitch.  # noqa: E501

        :param ip_pool_id: The ip_pool_id of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._ip_pool_id = ip_pool_id

    @property
    def vlan(self):
        """Gets the vlan of this LogicalSwitch.  # noqa: E501

        This property is dedicated to VLAN based network, to set VLAN of logical network. It is mutually exclusive with 'vlan_trunk_spec'.   # noqa: E501

        :return: The vlan of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._vlan

    @vlan.setter
    def vlan(self, vlan):
        """Sets the vlan of this LogicalSwitch.

        This property is dedicated to VLAN based network, to set VLAN of logical network. It is mutually exclusive with 'vlan_trunk_spec'.   # noqa: E501

        :param vlan: The vlan of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._vlan = vlan

    @property
    def hybrid(self):
        """Gets the hybrid of this LogicalSwitch.  # noqa: E501

        If this flag is set to true, then all the logical switch ports attached to this logical switch will behave in a hybrid fashion. The hybrid logical switch port indicates to NSX that the VM intends to operate in underlay mode, but retains the ability to forward egress traffic to the NSX overlay network. This flag can be enabled only for the logical switches in the overlay type transport zone which has host switch mode as STANDARD and also has either CrossCloud or CloudScope tag scopes. Only the NSX public cloud gateway (PCG) uses this flag, other host agents like ESX, KVM and Edge will ignore it. This property cannot be modified once the logical switch is created.   # noqa: E501

        :return: The hybrid of this LogicalSwitch.  # noqa: E501
        :rtype: bool
        """
        return self._hybrid

    @hybrid.setter
    def hybrid(self, hybrid):
        """Sets the hybrid of this LogicalSwitch.

        If this flag is set to true, then all the logical switch ports attached to this logical switch will behave in a hybrid fashion. The hybrid logical switch port indicates to NSX that the VM intends to operate in underlay mode, but retains the ability to forward egress traffic to the NSX overlay network. This flag can be enabled only for the logical switches in the overlay type transport zone which has host switch mode as STANDARD and also has either CrossCloud or CloudScope tag scopes. Only the NSX public cloud gateway (PCG) uses this flag, other host agents like ESX, KVM and Edge will ignore it. This property cannot be modified once the logical switch is created.   # noqa: E501

        :param hybrid: The hybrid of this LogicalSwitch.  # noqa: E501
        :type: bool
        """

        self._hybrid = hybrid

    @property
    def mac_pool_id(self):
        """Gets the mac_pool_id of this LogicalSwitch.  # noqa: E501

        Mac pool id that associated with a LogicalSwitch.  # noqa: E501

        :return: The mac_pool_id of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._mac_pool_id

    @mac_pool_id.setter
    def mac_pool_id(self, mac_pool_id):
        """Sets the mac_pool_id of this LogicalSwitch.

        Mac pool id that associated with a LogicalSwitch.  # noqa: E501

        :param mac_pool_id: The mac_pool_id of this LogicalSwitch.  # noqa: E501
        :type: str
        """

        self._mac_pool_id = mac_pool_id

    @property
    def vni(self):
        """Gets the vni of this LogicalSwitch.  # noqa: E501

        Only for OVERLAY network. A VNI will be auto-allocated from the default VNI pool if not given; otherwise the given VNI has to be inside the default pool and not used by any other LogicalSwitch.   # noqa: E501

        :return: The vni of this LogicalSwitch.  # noqa: E501
        :rtype: int
        """
        return self._vni

    @vni.setter
    def vni(self, vni):
        """Sets the vni of this LogicalSwitch.

        Only for OVERLAY network. A VNI will be auto-allocated from the default VNI pool if not given; otherwise the given VNI has to be inside the default pool and not used by any other LogicalSwitch.   # noqa: E501

        :param vni: The vni of this LogicalSwitch.  # noqa: E501
        :type: int
        """

        self._vni = vni

    @property
    def vlan_trunk_spec(self):
        """Gets the vlan_trunk_spec of this LogicalSwitch.  # noqa: E501


        :return: The vlan_trunk_spec of this LogicalSwitch.  # noqa: E501
        :rtype: VlanTrunkSpec
        """
        return self._vlan_trunk_spec

    @vlan_trunk_spec.setter
    def vlan_trunk_spec(self, vlan_trunk_spec):
        """Sets the vlan_trunk_spec of this LogicalSwitch.


        :param vlan_trunk_spec: The vlan_trunk_spec of this LogicalSwitch.  # noqa: E501
        :type: VlanTrunkSpec
        """

        self._vlan_trunk_spec = vlan_trunk_spec

    @property
    def admin_state(self):
        """Gets the admin_state of this LogicalSwitch.  # noqa: E501

        Represents Desired state of the Logical Switch  # noqa: E501

        :return: The admin_state of this LogicalSwitch.  # noqa: E501
        :rtype: str
        """
        return self._admin_state

    @admin_state.setter
    def admin_state(self, admin_state):
        """Sets the admin_state of this LogicalSwitch.

        Represents Desired state of the Logical Switch  # noqa: E501

        :param admin_state: The admin_state of this LogicalSwitch.  # noqa: E501
        :type: str
        """
        if admin_state is None:
            raise ValueError("Invalid value for `admin_state`, must not be `None`")  # noqa: E501
        allowed_values = ["UP", "DOWN"]  # noqa: E501
        if admin_state not in allowed_values:
            raise ValueError(
                "Invalid value for `admin_state` ({0}), must be one of {1}"  # noqa: E501
                .format(admin_state, allowed_values)
            )

        self._admin_state = admin_state

    @property
    def address_bindings(self):
        """Gets the address_bindings of this LogicalSwitch.  # noqa: E501

        Address bindings for the Logical switch  # noqa: E501

        :return: The address_bindings of this LogicalSwitch.  # noqa: E501
        :rtype: list[PacketAddressClassifier]
        """
        return self._address_bindings

    @address_bindings.setter
    def address_bindings(self, address_bindings):
        """Sets the address_bindings of this LogicalSwitch.

        Address bindings for the Logical switch  # noqa: E501

        :param address_bindings: The address_bindings of this LogicalSwitch.  # noqa: E501
        :type: list[PacketAddressClassifier]
        """

        self._address_bindings = address_bindings

    @property
    def switching_profile_ids(self):
        """Gets the switching_profile_ids of this LogicalSwitch.  # noqa: E501


        :return: The switching_profile_ids of this LogicalSwitch.  # noqa: E501
        :rtype: list[SwitchingProfileTypeIdEntry]
        """
        return self._switching_profile_ids

    @switching_profile_ids.setter
    def switching_profile_ids(self, switching_profile_ids):
        """Sets the switching_profile_ids of this LogicalSwitch.


        :param switching_profile_ids: The switching_profile_ids of this LogicalSwitch.  # noqa: E501
        :type: list[SwitchingProfileTypeIdEntry]
        """

        self._switching_profile_ids = switching_profile_ids

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LogicalSwitch, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LogicalSwitch):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
