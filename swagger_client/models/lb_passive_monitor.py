# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 2.5.1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class LbPassiveMonitor(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'resource_type': 'str',
        'max_fails': 'int',
        'timeout': 'int'
    }
    if hasattr(LbMonitor, "swagger_types"):
        swagger_types.update(LbMonitor.swagger_types)

    attribute_map = {
        'resource_type': 'resource_type',
        'max_fails': 'max_fails',
        'timeout': 'timeout'
    }
    if hasattr(LbMonitor, "attribute_map"):
        attribute_map.update(LbMonitor.attribute_map)

    def __init__(self, resource_type=None, max_fails=5, timeout=5, *args, **kwargs):  # noqa: E501
        """LbPassiveMonitor - a model defined in Swagger"""  # noqa: E501
        self._resource_type = None
        self._max_fails = None
        self._timeout = None
        self.discriminator = None
        self.resource_type = resource_type
        if max_fails is not None:
            self.max_fails = max_fails
        if timeout is not None:
            self.timeout = timeout
        LbMonitor.__init__(self, *args, **kwargs)

    @property
    def resource_type(self):
        """Gets the resource_type of this LbPassiveMonitor.  # noqa: E501

        Load balancers monitor the health of backend servers to ensure traffic is not black holed. There are two types of healthchecks: active and passive. Passive healthchecks depend on failures in actual client traffic (e.g. RST from server in response to a client connection) to detect that the server or the application is down. In case of active healthchecks, load balancer itself initiates new connections (or sends ICMP ping) to the servers periodically to check their health, completely independent of any data traffic. Currently, active health monitors are supported for HTTP, HTTPS, TCP, UDP and ICMP protocols.   # noqa: E501

        :return: The resource_type of this LbPassiveMonitor.  # noqa: E501
        :rtype: str
        """
        return self._resource_type

    @resource_type.setter
    def resource_type(self, resource_type):
        """Sets the resource_type of this LbPassiveMonitor.

        Load balancers monitor the health of backend servers to ensure traffic is not black holed. There are two types of healthchecks: active and passive. Passive healthchecks depend on failures in actual client traffic (e.g. RST from server in response to a client connection) to detect that the server or the application is down. In case of active healthchecks, load balancer itself initiates new connections (or sends ICMP ping) to the servers periodically to check their health, completely independent of any data traffic. Currently, active health monitors are supported for HTTP, HTTPS, TCP, UDP and ICMP protocols.   # noqa: E501

        :param resource_type: The resource_type of this LbPassiveMonitor.  # noqa: E501
        :type: str
        """
        if resource_type is None:
            raise ValueError("Invalid value for `resource_type`, must not be `None`")  # noqa: E501
        allowed_values = ["LbHttpMonitor", "LbHttpsMonitor", "LbIcmpMonitor", "LbTcpMonitor", "LbUdpMonitor", "LbPassiveMonitor"]  # noqa: E501
        if resource_type not in allowed_values:
            raise ValueError(
                "Invalid value for `resource_type` ({0}), must be one of {1}"  # noqa: E501
                .format(resource_type, allowed_values)
            )

        self._resource_type = resource_type

    @property
    def max_fails(self):
        """Gets the max_fails of this LbPassiveMonitor.  # noqa: E501

        When the consecutive failures reach this value, then the member is considered temporarily unavailable for a configurable period   # noqa: E501

        :return: The max_fails of this LbPassiveMonitor.  # noqa: E501
        :rtype: int
        """
        return self._max_fails

    @max_fails.setter
    def max_fails(self, max_fails):
        """Sets the max_fails of this LbPassiveMonitor.

        When the consecutive failures reach this value, then the member is considered temporarily unavailable for a configurable period   # noqa: E501

        :param max_fails: The max_fails of this LbPassiveMonitor.  # noqa: E501
        :type: int
        """

        self._max_fails = max_fails

    @property
    def timeout(self):
        """Gets the timeout of this LbPassiveMonitor.  # noqa: E501

        After this timeout period, the member is tried again for a new connection to see if it is available.   # noqa: E501

        :return: The timeout of this LbPassiveMonitor.  # noqa: E501
        :rtype: int
        """
        return self._timeout

    @timeout.setter
    def timeout(self, timeout):
        """Sets the timeout of this LbPassiveMonitor.

        After this timeout period, the member is tried again for a new connection to see if it is available.   # noqa: E501

        :param timeout: The timeout of this LbPassiveMonitor.  # noqa: E501
        :type: int
        """

        self._timeout = timeout

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LbPassiveMonitor, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LbPassiveMonitor):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
