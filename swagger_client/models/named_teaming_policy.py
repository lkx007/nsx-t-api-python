# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 2.5.1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class NamedTeamingPolicy(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'policy': 'str',
        'standby_list': 'list[Uplink]',
        'active_list': 'list[Uplink]',
        'name': 'str'
    }
    if hasattr(TeamingPolicy, "swagger_types"):
        swagger_types.update(TeamingPolicy.swagger_types)

    attribute_map = {
        'policy': 'policy',
        'standby_list': 'standby_list',
        'active_list': 'active_list',
        'name': 'name'
    }
    if hasattr(TeamingPolicy, "attribute_map"):
        attribute_map.update(TeamingPolicy.attribute_map)

    def __init__(self, policy=None, standby_list=None, active_list=None, name=None, *args, **kwargs):  # noqa: E501
        """NamedTeamingPolicy - a model defined in Swagger"""  # noqa: E501
        self._policy = None
        self._standby_list = None
        self._active_list = None
        self._name = None
        self.discriminator = None
        self.policy = policy
        if standby_list is not None:
            self.standby_list = standby_list
        self.active_list = active_list
        self.name = name
        TeamingPolicy.__init__(self, *args, **kwargs)

    @property
    def policy(self):
        """Gets the policy of this NamedTeamingPolicy.  # noqa: E501

        Teaming policy  # noqa: E501

        :return: The policy of this NamedTeamingPolicy.  # noqa: E501
        :rtype: str
        """
        return self._policy

    @policy.setter
    def policy(self, policy):
        """Sets the policy of this NamedTeamingPolicy.

        Teaming policy  # noqa: E501

        :param policy: The policy of this NamedTeamingPolicy.  # noqa: E501
        :type: str
        """
        if policy is None:
            raise ValueError("Invalid value for `policy`, must not be `None`")  # noqa: E501
        allowed_values = ["FAILOVER_ORDER", "LOADBALANCE_SRCID", "LOADBALANCE_SRC_MAC"]  # noqa: E501
        if policy not in allowed_values:
            raise ValueError(
                "Invalid value for `policy` ({0}), must be one of {1}"  # noqa: E501
                .format(policy, allowed_values)
            )

        self._policy = policy

    @property
    def standby_list(self):
        """Gets the standby_list of this NamedTeamingPolicy.  # noqa: E501

        List of Uplinks used in standby list  # noqa: E501

        :return: The standby_list of this NamedTeamingPolicy.  # noqa: E501
        :rtype: list[Uplink]
        """
        return self._standby_list

    @standby_list.setter
    def standby_list(self, standby_list):
        """Sets the standby_list of this NamedTeamingPolicy.

        List of Uplinks used in standby list  # noqa: E501

        :param standby_list: The standby_list of this NamedTeamingPolicy.  # noqa: E501
        :type: list[Uplink]
        """

        self._standby_list = standby_list

    @property
    def active_list(self):
        """Gets the active_list of this NamedTeamingPolicy.  # noqa: E501

        List of Uplinks used in active list  # noqa: E501

        :return: The active_list of this NamedTeamingPolicy.  # noqa: E501
        :rtype: list[Uplink]
        """
        return self._active_list

    @active_list.setter
    def active_list(self, active_list):
        """Sets the active_list of this NamedTeamingPolicy.

        List of Uplinks used in active list  # noqa: E501

        :param active_list: The active_list of this NamedTeamingPolicy.  # noqa: E501
        :type: list[Uplink]
        """
        if active_list is None:
            raise ValueError("Invalid value for `active_list`, must not be `None`")  # noqa: E501

        self._active_list = active_list

    @property
    def name(self):
        """Gets the name of this NamedTeamingPolicy.  # noqa: E501

        An uplink teaming policy of a given name defined in UplinkHostSwitchProfile. The names of all NamedTeamingPolicies in an UplinkHostSwitchProfile must be different, but a name can be shared by different UplinkHostSwitchProfiles. Different TransportNodes can use different NamedTeamingPolicies having the same name in different UplinkHostSwitchProfiles to realize an uplink teaming policy on a logical switch. An uplink teaming policy on a logical switch can be any policy defined by a user; it does not have to be a single type of FAILOVER or LOADBALANCE. It can be a combination of types, for instance, a user can define a policy with name \"MyHybridTeamingPolicy\" as \"FAILOVER on all ESX TransportNodes and LOADBALANCE on all KVM TransportNodes\". The name is the key of the teaming policy and can not be changed once assigned.  # noqa: E501

        :return: The name of this NamedTeamingPolicy.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this NamedTeamingPolicy.

        An uplink teaming policy of a given name defined in UplinkHostSwitchProfile. The names of all NamedTeamingPolicies in an UplinkHostSwitchProfile must be different, but a name can be shared by different UplinkHostSwitchProfiles. Different TransportNodes can use different NamedTeamingPolicies having the same name in different UplinkHostSwitchProfiles to realize an uplink teaming policy on a logical switch. An uplink teaming policy on a logical switch can be any policy defined by a user; it does not have to be a single type of FAILOVER or LOADBALANCE. It can be a combination of types, for instance, a user can define a policy with name \"MyHybridTeamingPolicy\" as \"FAILOVER on all ESX TransportNodes and LOADBALANCE on all KVM TransportNodes\". The name is the key of the teaming policy and can not be changed once assigned.  # noqa: E501

        :param name: The name of this NamedTeamingPolicy.  # noqa: E501
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(NamedTeamingPolicy, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, NamedTeamingPolicy):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
