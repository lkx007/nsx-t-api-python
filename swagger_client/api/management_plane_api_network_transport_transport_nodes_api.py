# coding: utf-8

"""
    NSX-T Manager API

    VMware NSX-T Manager REST API  # noqa: E501

    OpenAPI spec version: 2.5.1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ManagementPlaneApiNetworkTransportTransportNodesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_compute_collection_transport_node_template_and_tn_collection(self, body, **kwargs):  # noqa: E501
        """Create transport node template for compute collection.  # noqa: E501

        If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_compute_collection_transport_node_template_and_tn_collection(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ComputeCollectionTransportNodeTemplate body: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_compute_collection_transport_node_template_and_tn_collection_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_compute_collection_transport_node_template_and_tn_collection_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_compute_collection_transport_node_template_and_tn_collection_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create transport node template for compute collection.  # noqa: E501

        If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_compute_collection_transport_node_template_and_tn_collection_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ComputeCollectionTransportNodeTemplate body: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_compute_collection_transport_node_template_and_tn_collection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_compute_collection_transport_node_template_and_tn_collection`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_network_migration_spec(self, body, **kwargs):  # noqa: E501
        """Create a template of network migration specification.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_network_migration_spec(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetworkMigrationSpec body: (required)
        :return: NetworkMigrationSpec
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_network_migration_spec_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_network_migration_spec_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_network_migration_spec_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a template of network migration specification.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_network_migration_spec_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetworkMigrationSpec body: (required)
        :return: NetworkMigrationSpec
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_network_migration_spec" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_network_migration_spec`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-migration-specs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkMigrationSpec',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_transport_node_with_deployment_info(self, body, **kwargs):  # noqa: E501
        """Create a Transport Node  # noqa: E501

        Transport nodes are hypervisor hosts and NSX Edges that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches. For NSX Edges, this means that it will have logical router uplinks and downlinks.  This API creates transport node for a host node (hypervisor) or edge node (router) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the <b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b> command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'. If the key is not present then generate a new key by running the following command and follow the instructions.  <b>ssh-keygen -t rsa</b>  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default 'id_rsa.pub'.  <b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b> This api is deprecated as part of FN+TN unification. Please use Transport Node API to install NSX components on a node.  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host or NSX Edge node, NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts or NSX Edge nodes.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 5 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  Note: previous versions of NSX-T used a property named host_switches to specify the host switch configuration on the transport node. That property is deprecated, but still functions. You should configure new host switches using the host_switch_spec property.  The request should either provide node_deployement_info or node_id.  If the host node (hypervisor) or edge node (router) is already added in system then it can be converted to transport node by providing node_id in request.  If host node (hypervisor) or edge node (router) is not already present in system then information should be provided under node_deployment_info.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_transport_node_with_deployment_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransportNode body: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_transport_node_with_deployment_info_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_transport_node_with_deployment_info_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_transport_node_with_deployment_info_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Transport Node  # noqa: E501

        Transport nodes are hypervisor hosts and NSX Edges that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches. For NSX Edges, this means that it will have logical router uplinks and downlinks.  This API creates transport node for a host node (hypervisor) or edge node (router) in the transport network.  When you run this command for a host, NSX Manager attempts to install the NSX kernel modules, which are packaged as VIB, RPM, or DEB files. For the installation to succeed, you must provide the host login credentials and the host thumbprint.  To get the ESXi host thumbprint, SSH to the host and run the <b>openssl x509 -in /etc/vmware/ssl/rui.crt -fingerprint -sha256 -noout</b> command.  To generate host key thumbprint using SHA-256 algorithm please follow the steps below.  Log into the host, making sure that the connection is not vulnerable to a man in the middle attack. Check whether a public key already exists. Host public key is generally located at '/etc/ssh/ssh_host_rsa_key.pub'. If the key is not present then generate a new key by running the following command and follow the instructions.  <b>ssh-keygen -t rsa</b>  Now generate a SHA256 hash of the key using the following command. Please make sure to pass the appropriate file name if the public key is stored with a different file name other than the default 'id_rsa.pub'.  <b>awk '{print $2}' id_rsa.pub | base64 -d | sha256sum -b | sed 's/ .*$//' | xxd -r -p | base64</b> This api is deprecated as part of FN+TN unification. Please use Transport Node API to install NSX components on a node.  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  In order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host or NSX Edge node, NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts or NSX Edge nodes.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 5 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  Note: previous versions of NSX-T used a property named host_switches to specify the host switch configuration on the transport node. That property is deprecated, but still functions. You should configure new host switches using the host_switch_spec property.  The request should either provide node_deployement_info or node_id.  If the host node (hypervisor) or edge node (router) is already added in system then it can be converted to transport node by providing node_id in request.  If host node (hypervisor) or edge node (router) is not already present in system then information should be provided under node_deployment_info.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_transport_node_with_deployment_info_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransportNode body: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_transport_node_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_transport_node_with_deployment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_compute_collection_transport_node_template_and_tn_collection(self, template_id, **kwargs):  # noqa: E501
        """Delete a compute collection transport node template  # noqa: E501

        Delete the specified compute collection transport node template. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_compute_collection_transport_node_template_and_tn_collection(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_compute_collection_transport_node_template_and_tn_collection_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_compute_collection_transport_node_template_and_tn_collection_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def delete_compute_collection_transport_node_template_and_tn_collection_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Delete a compute collection transport node template  # noqa: E501

        Delete the specified compute collection transport node template. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_compute_collection_transport_node_template_and_tn_collection_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_compute_collection_transport_node_template_and_tn_collection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `delete_compute_collection_transport_node_template_and_tn_collection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_network_migration_spec(self, template_id, **kwargs):  # noqa: E501
        """Delete a network migration specification template  # noqa: E501

        Delete the specified network migration specification template. Delete will fail if this is a HostProfileNetworkMigrationSpec and is associated with certain compute collection. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_network_migration_spec(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_network_migration_spec_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_network_migration_spec_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def delete_network_migration_spec_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Delete a network migration specification template  # noqa: E501

        Delete the specified network migration specification template. Delete will fail if this is a HostProfileNetworkMigrationSpec and is associated with certain compute collection. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_network_migration_spec_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_network_migration_spec" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `delete_network_migration_spec`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-migration-specs/{template-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transport_node_with_deployment_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Delete a Transport Node  # noqa: E501

        Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force deletion of edge and public cloud gateway nodes is not supported.  It also removes the specified node (host or edge) from system. If unprepare_host option is set to false, then host will be deleted without uninstalling the NSX components from the host.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transport_node_with_deployment_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :param bool unprepare_host: Uninstall NSX components from host while deleting
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_transport_node_with_deployment_info_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transport_node_with_deployment_info_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def delete_transport_node_with_deployment_info_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Delete a Transport Node  # noqa: E501

        Deletes the specified transport node. Query param force can be used to force delete the host nodes. Force deletion of edge and public cloud gateway nodes is not supported.  It also removes the specified node (host or edge) from system. If unprepare_host option is set to false, then host will be deleted without uninstalling the NSX components from the host.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transport_node_with_deployment_info_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :param bool unprepare_host: Uninstall NSX components from host while deleting
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id', 'force', 'unprepare_host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transport_node_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `delete_transport_node_with_deployment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501
        if 'unprepare_host' in params:
            query_params.append(('unprepare_host', params['unprepare_host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_flow_cache_disable_flow_cache(self, transport_node_id, **kwargs):  # noqa: E501
        """Disable flow cache for an edge transport node  # noqa: E501

        Disable flow cache for edge transport node. Caution: This involves restart of the edge dataplane and hence may lead to network disruption.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_flow_cache_disable_flow_cache(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_flow_cache_disable_flow_cache_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_flow_cache_disable_flow_cache_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def disable_flow_cache_disable_flow_cache_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Disable flow cache for an edge transport node  # noqa: E501

        Disable flow cache for edge transport node. Caution: This involves restart of the edge dataplane and hence may lead to network disruption.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_flow_cache_disable_flow_cache_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_flow_cache_disable_flow_cache" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `disable_flow_cache_disable_flow_cache`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}?action=disable_flow_cache', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_flow_cache_enable_flow_cache(self, transport_node_id, **kwargs):  # noqa: E501
        """Enable flow cache for an edge transport node  # noqa: E501

        Enable flow cache for edge transport node. Caution: This involves restart of the edge dataplane and hence may lead to network disruption.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_flow_cache_enable_flow_cache(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_flow_cache_enable_flow_cache_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_flow_cache_enable_flow_cache_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def enable_flow_cache_enable_flow_cache_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Enable flow cache for an edge transport node  # noqa: E501

        Enable flow cache for edge transport node. Caution: This involves restart of the edge dataplane and hence may lead to network disruption.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_flow_cache_enable_flow_cache_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_flow_cache_enable_flow_cache" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `enable_flow_cache_enable_flow_cache`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}?action=enable_flow_cache', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_transport_nodes_status(self, **kwargs):  # noqa: E501
        """Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.  # noqa: E501

        Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_transport_nodes_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_type: Transport node type
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_transport_nodes_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_transport_nodes_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_transport_nodes_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.  # noqa: E501

        Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_transport_nodes_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_type: Transport node type
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_transport_nodes_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'node_type' in params:
            query_params.append(('node_type', params['node_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeatMapTransportZoneStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_transport_zone_status(self, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.  # noqa: E501

        Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_transport_zone_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HeatMapTransportNodesAggregateStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_transport_zone_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_transport_zone_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_transport_zone_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.  # noqa: E501

        Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_transport_zone_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HeatMapTransportNodesAggregateStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_transport_zone_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeatMapTransportNodesAggregateStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compute_collection_transport_node_template(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template by id  # noqa: E501

        Returns compute collection transportnode template by id Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_collection_transport_node_template(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_compute_collection_transport_node_template_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_compute_collection_transport_node_template_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def get_compute_collection_transport_node_template_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template by id  # noqa: E501

        Returns compute collection transportnode template by id Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_collection_transport_node_template_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_collection_transport_node_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `get_compute_collection_transport_node_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compute_collection_transport_node_template_state(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template application states  # noqa: E501

        Returns detailed transport node states for this compute collection Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_collection_transport_node_template_state(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :param str compute_collection_id: Compute collection id
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ComputeCollectionTransportNodeTemplateStateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_compute_collection_transport_node_template_state_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_compute_collection_transport_node_template_state_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def get_compute_collection_transport_node_template_state_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template application states  # noqa: E501

        Returns detailed transport node states for this compute collection Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_collection_transport_node_template_state_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :param str compute_collection_id: Compute collection id
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ComputeCollectionTransportNodeTemplateStateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id', 'compute_collection_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_collection_transport_node_template_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `get_compute_collection_transport_node_template_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []
        if 'compute_collection_id' in params:
            query_params.append(('compute_collection_id', params['compute_collection_id']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplateStateList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fabric_node_modules_of_transport_node(self, node_id, **kwargs):  # noqa: E501
        """Get the module details of a transport node   # noqa: E501

        Get the module details of a transport node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fabric_node_modules_of_transport_node(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: (required)
        :return: SoftwareModuleResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_fabric_node_modules_of_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fabric_node_modules_of_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_fabric_node_modules_of_transport_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Get the module details of a transport node   # noqa: E501

        Get the module details of a transport node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fabric_node_modules_of_transport_node_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: (required)
        :return: SoftwareModuleResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fabric_node_modules_of_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_fabric_node_modules_of_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/modules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SoftwareModuleResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_heatmap_transport_zone_status(self, zone_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone  # noqa: E501

        Get high-level summary of a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_heatmap_transport_zone_status(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_heatmap_transport_zone_status_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_heatmap_transport_zone_status_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def get_heatmap_transport_zone_status_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone  # noqa: E501

        Get high-level summary of a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_heatmap_transport_zone_status_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_heatmap_transport_zone_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `get_heatmap_transport_zone_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeatMapTransportZoneStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network_migration_spec(self, template_id, **kwargs):  # noqa: E501
        """Get network migration specification template by id.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_migration_spec(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: NetworkMigrationSpec
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_network_migration_spec_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_network_migration_spec_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def get_network_migration_spec_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get network migration specification template by id.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_migration_spec_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template_id: (required)
        :return: NetworkMigrationSpec
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network_migration_spec" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `get_network_migration_spec`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-migration-specs/{template-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkMigrationSpec',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pnic_statuses_for_transport_node(self, node_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport node  # noqa: E501

        Get high-level summary of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pnic_statuses_for_transport_node(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str status: pNic/bond status
        :return: PnicBondStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pnic_statuses_for_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pnic_statuses_for_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_pnic_statuses_for_transport_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport node  # noqa: E501

        Get high-level summary of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pnic_statuses_for_transport_node_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str status: pNic/bond status
        :return: PnicBondStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pnic_statuses_for_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_pnic_statuses_for_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/pnic-bond-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PnicBondStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_report(self, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes of all the transport zones  # noqa: E501

        You must provide the request header \"Accept:application/octet-stream\" when calling this API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_report(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_node_report_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_report_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_transport_node_report_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes of all the transport zones  # noqa: E501

        You must provide the request header \"Accept:application/octet-stream\" when calling this API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_report_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_report" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/transport-node-status-report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_report_for_a_transport_zone(self, zone_id, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes in a transport zone  # noqa: E501

        You must provide the request header \"Accept:application/octet-stream\" when calling this API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_report_for_a_transport_zone(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_report_for_a_transport_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes in a transport zone  # noqa: E501

        You must provide the request header \"Accept:application/octet-stream\" when calling this API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'source', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_report_for_a_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `get_transport_node_report_for_a_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/transport-node-status-report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_state_with_deployment_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Get a Transport Node's State  # noqa: E501

        Returns information about the current state of the transport node configuration and information about the associated hostswitch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_state_with_deployment_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: TransportNodeState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_node_state_with_deployment_info_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_state_with_deployment_info_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_state_with_deployment_info_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Get a Transport Node's State  # noqa: E501

        Returns information about the current state of the transport node configuration and information about the associated hostswitch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_state_with_deployment_info_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: TransportNodeState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_state_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_transport_node_state_with_deployment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeState',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_status(self, node_id, **kwargs):  # noqa: E501
        """Read status of a transport node  # noqa: E501

        Read status of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_status(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str source: Data source type.
        :return: TransportNodeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_status_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read status of a transport node  # noqa: E501

        Read status of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_status_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str source: Data source type.
        :return: TransportNodeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_transport_node_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_with_deployment_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Get a Transport Node  # noqa: E501

        Returns information about a specified transport node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_with_deployment_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transport_node_with_deployment_info_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_with_deployment_info_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_with_deployment_info_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Get a Transport Node  # noqa: E501

        Returns information about a specified transport node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transport_node_with_deployment_info_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_transport_node_with_deployment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tunnel(self, node_id, tunnel_name, **kwargs):  # noqa: E501
        """Tunnel properties  # noqa: E501

        Tunnel properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tunnel(node_id, tunnel_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str tunnel_name: Tunnel name (required)
        :param str source: Data source type.
        :return: TunnelProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tunnel_with_http_info(node_id, tunnel_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tunnel_with_http_info(node_id, tunnel_name, **kwargs)  # noqa: E501
            return data

    def get_tunnel_with_http_info(self, node_id, tunnel_name, **kwargs):  # noqa: E501
        """Tunnel properties  # noqa: E501

        Tunnel properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tunnel_with_http_info(node_id, tunnel_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str tunnel_name: Tunnel name (required)
        :param str source: Data source type.
        :return: TunnelProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'tunnel_name', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tunnel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_tunnel`")  # noqa: E501
        # verify the required parameter 'tunnel_name' is set
        if ('tunnel_name' not in params or
                params['tunnel_name'] is None):
            raise ValueError("Missing the required parameter `tunnel_name` when calling `get_tunnel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501
        if 'tunnel_name' in params:
            path_params['tunnel-name'] = params['tunnel_name']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/tunnels/{tunnel-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TunnelProperties',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_compute_collection_transport_node_templates(self, **kwargs):  # noqa: E501
        """List compute collection transportnode templates  # noqa: E501

        Returns all eligible compute collection transportnode templates Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_compute_collection_transport_node_templates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str compute_collection_id: Compute collection id
        :return: TransportNodeTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_compute_collection_transport_node_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_compute_collection_transport_node_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_compute_collection_transport_node_templates_with_http_info(self, **kwargs):  # noqa: E501
        """List compute collection transportnode templates  # noqa: E501

        Returns all eligible compute collection transportnode templates Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_compute_collection_transport_node_templates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str compute_collection_id: Compute collection id
        :return: TransportNodeTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['compute_collection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_compute_collection_transport_node_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'compute_collection_id' in params:
            query_params.append(('compute_collection_id', params['compute_collection_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeTemplateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_neighbor_properties(self, node_id, **kwargs):  # noqa: E501
        """List LLDP Neighbor Properties of Transport Node  # noqa: E501

        List LLDP Neighbor Properties for all interfaces of Transport Node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_neighbor_properties(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :return: InterfaceNeighborPropertyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_neighbor_properties_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_neighbor_properties_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def list_neighbor_properties_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """List LLDP Neighbor Properties of Transport Node  # noqa: E501

        List LLDP Neighbor Properties for all interfaces of Transport Node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_neighbor_properties_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :return: InterfaceNeighborPropertyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_neighbor_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `list_neighbor_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/lldp/transport-nodes/{node-id}/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceNeighborPropertyListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_network_migration_specs(self, **kwargs):  # noqa: E501
        """List all network migration specification templates.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_network_migration_specs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: Supported network migration specification types.
        :return: NetworkMigrationSpecListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_network_migration_specs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_network_migration_specs_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_network_migration_specs_with_http_info(self, **kwargs):  # noqa: E501
        """List all network migration specification templates.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_network_migration_specs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: Supported network migration specification types.
        :return: NetworkMigrationSpecListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'include_system_owned', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_network_migration_specs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'include_system_owned' in params:
            query_params.append(('include_system_owned', params['include_system_owned']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-migration-specs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkMigrationSpecListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_remote_transport_node_status(self, node_id, **kwargs):  # noqa: E501
        """Read status of all transport nodes with tunnel connections to transport node   # noqa: E501

        Read status of all transport nodes with tunnel connections to transport node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_remote_transport_node_status(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str bfd_diagnostic_code: BFD diagnostic code of Tunnel
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str tunnel_status: Tunnel Status
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_remote_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_remote_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def list_remote_transport_node_status_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read status of all transport nodes with tunnel connections to transport node   # noqa: E501

        Read status of all transport nodes with tunnel connections to transport node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_remote_transport_node_status_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str bfd_diagnostic_code: BFD diagnostic code of Tunnel
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str tunnel_status: Tunnel Status
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'bfd_diagnostic_code', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'tunnel_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_remote_transport_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `list_remote_transport_node_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'bfd_diagnostic_code' in params:
            query_params.append(('bfd_diagnostic_code', params['bfd_diagnostic_code']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'tunnel_status' in params:
            query_params.append(('tunnel_status', params['tunnel_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/remote-transport-node-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_node_capabilities(self, transport_node_id, **kwargs):  # noqa: E501
        """Return the list of capabilities of transport node  # noqa: E501

        Returns information about capabilities of transport host node. Edge nodes do not have capabilities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_capabilities(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: NodeCapabilitiesResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_transport_node_capabilities_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_node_capabilities_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def list_transport_node_capabilities_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Return the list of capabilities of transport node  # noqa: E501

        Returns information about capabilities of transport host node. Edge nodes do not have capabilities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_capabilities_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: NodeCapabilitiesResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_node_capabilities" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `list_transport_node_capabilities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}/capabilities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeCapabilitiesResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_node_interfaces(self, transport_node_id, **kwargs):  # noqa: E501
        """List the specified transport node's network interfaces  # noqa: E501

        Returns the number of interfaces on the node and detailed information about each interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_interfaces(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param str source: Data source type.
        :return: NodeInterfacePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_transport_node_interfaces_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_node_interfaces_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def list_transport_node_interfaces_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """List the specified transport node's network interfaces  # noqa: E501

        Returns the number of interfaces on the node and detailed information about each interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_interfaces_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param str source: Data source type.
        :return: NodeInterfacePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_node_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `list_transport_node_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}/network/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfacePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_node_status(self, **kwargs):  # noqa: E501
        """Read status of all the transport nodes  # noqa: E501

        Read status of all the transport nodes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_transport_node_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_node_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_node_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read status of all the transport nodes  # noqa: E501

        Read status of all the transport nodes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_node_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/transport-node-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_node_status_for_transport_zone(self, zone_id, **kwargs):  # noqa: E501
        """Read status of transport nodes in a transport zone  # noqa: E501

        Read status of transport nodes in a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_status_for_transport_zone(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str zone_id: ID of transport zone (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_transport_node_status_for_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_node_status_for_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def list_transport_node_status_for_transport_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Read status of transport nodes in a transport zone  # noqa: E501

        Read status of transport nodes in a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_node_status_for_transport_zone_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str zone_id: ID of transport zone (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_node_status_for_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `list_transport_node_status_for_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/transport-node-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_nodes_by_state_with_deployment_info(self, **kwargs):  # noqa: E501
        """List transport nodes by realized state  # noqa: E501

        Returns a list of transport node states that have realized state as provided as query parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_nodes_by_state_with_deployment_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mm_state: maintenance mode state
        :param str status: Realized state of transport nodes
        :param str vtep_ip: Virtual tunnel endpoint ip address of transport node
        :return: TransportNodeStateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_transport_nodes_by_state_with_deployment_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_nodes_by_state_with_deployment_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_nodes_by_state_with_deployment_info_with_http_info(self, **kwargs):  # noqa: E501
        """List transport nodes by realized state  # noqa: E501

        Returns a list of transport node states that have realized state as provided as query parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_nodes_by_state_with_deployment_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mm_state: maintenance mode state
        :param str status: Realized state of transport nodes
        :param str vtep_ip: Virtual tunnel endpoint ip address of transport node
        :return: TransportNodeStateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mm_state', 'status', 'vtep_ip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_nodes_by_state_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mm_state' in params:
            query_params.append(('mm_state', params['mm_state']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'vtep_ip' in params:
            query_params.append(('vtep_ip', params['vtep_ip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_nodes_with_deployment_info(self, **kwargs):  # noqa: E501
        """List Transport Nodes  # noqa: E501

        Returns information about all transport nodes along with underlying host or edge details. A transport node is a host or edge that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has hostswitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_nodes_with_deployment_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool in_maintenance_mode: maintenance mode flag
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str node_id: node identifier
        :param str node_ip: Fabric node IP address
        :param str node_types: a list of fabric node types separated by comma or a single type
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str transport_zone_id: Transport zone identifier
        :return: TransportNodeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_transport_nodes_with_deployment_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_nodes_with_deployment_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_nodes_with_deployment_info_with_http_info(self, **kwargs):  # noqa: E501
        """List Transport Nodes  # noqa: E501

        Returns information about all transport nodes along with underlying host or edge details. A transport node is a host or edge that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has hostswitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_transport_nodes_with_deployment_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool in_maintenance_mode: maintenance mode flag
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param str node_id: node identifier
        :param str node_ip: Fabric node IP address
        :param str node_types: a list of fabric node types separated by comma or a single type
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str transport_zone_id: Transport zone identifier
        :return: TransportNodeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'in_maintenance_mode', 'included_fields', 'node_id', 'node_ip', 'node_types', 'page_size', 'sort_ascending', 'sort_by', 'transport_zone_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_nodes_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'in_maintenance_mode' in params:
            query_params.append(('in_maintenance_mode', params['in_maintenance_mode']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('node_id', params['node_id']))  # noqa: E501
        if 'node_ip' in params:
            query_params.append(('node_ip', params['node_ip']))  # noqa: E501
        if 'node_types' in params:
            query_params.append(('node_types', params['node_types']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_tunnels(self, node_id, **kwargs):  # noqa: E501
        """List of tunnels  # noqa: E501

        List of tunnels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_tunnels(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str bfd_diagnostic_code: BFD diagnostic code of Tunnel as defined in RFC 5880
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str remote_node_id:
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Tunnel status
        :return: TunnelList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.query_tunnels_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.query_tunnels_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def query_tunnels_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """List of tunnels  # noqa: E501

        List of tunnels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_tunnels_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str bfd_diagnostic_code: BFD diagnostic code of Tunnel as defined in RFC 5880
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included in query result
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str remote_node_id:
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Tunnel status
        :return: TunnelList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'bfd_diagnostic_code', 'cursor', 'included_fields', 'page_size', 'remote_node_id', 'sort_ascending', 'sort_by', 'source', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_tunnels" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `query_tunnels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'bfd_diagnostic_code' in params:
            query_params.append(('bfd_diagnostic_code', params['bfd_diagnostic_code']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'remote_node_id' in params:
            query_params.append(('remote_node_id', params['remote_node_id']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/tunnels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TunnelList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_neighbor_properties(self, node_id, interface_name, **kwargs):  # noqa: E501
        """Read LLDP Neighbor Properties of Transport Node by Interface Name   # noqa: E501

        Read LLDP Neighbor Properties for a specific interface of Transport Node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_neighbor_properties(node_id, interface_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str interface_name: Interface name to read (required)
        :return: InterfaceNeighborProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_neighbor_properties_with_http_info(node_id, interface_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_neighbor_properties_with_http_info(node_id, interface_name, **kwargs)  # noqa: E501
            return data

    def read_neighbor_properties_with_http_info(self, node_id, interface_name, **kwargs):  # noqa: E501
        """Read LLDP Neighbor Properties of Transport Node by Interface Name   # noqa: E501

        Read LLDP Neighbor Properties for a specific interface of Transport Node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_neighbor_properties_with_http_info(node_id, interface_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: ID of transport node (required)
        :param str interface_name: Interface name to read (required)
        :return: InterfaceNeighborProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'interface_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_neighbor_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_neighbor_properties`")  # noqa: E501
        # verify the required parameter 'interface_name' is set
        if ('interface_name' not in params or
                params['interface_name'] is None):
            raise ValueError("Missing the required parameter `interface_name` when calling `read_neighbor_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501
        if 'interface_name' in params:
            path_params['interface-name'] = params['interface_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/lldp/transport-nodes/{node-id}/interfaces/{interface-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceNeighborProperties',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_transport_node_interface(self, transport_node_id, interface_id, **kwargs):  # noqa: E501
        """Read the transport node's network interface  # noqa: E501

        Returns detailed information about the specified interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network  mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_transport_node_interface(transport_node_id, interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_transport_node_interface_with_http_info(transport_node_id, interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_transport_node_interface_with_http_info(transport_node_id, interface_id, **kwargs)  # noqa: E501
            return data

    def read_transport_node_interface_with_http_info(self, transport_node_id, interface_id, **kwargs):  # noqa: E501
        """Read the transport node's network interface  # noqa: E501

        Returns detailed information about the specified interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network  mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_transport_node_interface_with_http_info(transport_node_id, interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id', 'interface_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_transport_node_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `read_transport_node_interface`")  # noqa: E501
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `read_transport_node_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}/network/interfaces/{interface-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfaceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_transport_node_interface_statistics(self, transport_node_id, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager's Network Interface Statistics  # noqa: E501

        On the specified interface, returns the number of received (rx), transmitted (tx), and dropped packets; the number of bytes and errors received and transmitted on the interface; and the number of detected collisions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_transport_node_interface_statistics(transport_node_id, interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceStatisticsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.read_transport_node_interface_statistics_with_http_info(transport_node_id, interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_transport_node_interface_statistics_with_http_info(transport_node_id, interface_id, **kwargs)  # noqa: E501
            return data

    def read_transport_node_interface_statistics_with_http_info(self, transport_node_id, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager's Network Interface Statistics  # noqa: E501

        On the specified interface, returns the number of received (rx), transmitted (tx), and dropped packets; the number of bytes and errors received and transmitted on the interface; and the number of detected collisions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.read_transport_node_interface_statistics_with_http_info(transport_node_id, interface_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceStatisticsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id', 'interface_id', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_transport_node_interface_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `read_transport_node_interface_statistics`")  # noqa: E501
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `read_transport_node_interface_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}/network/interfaces/{interface-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfaceStatisticsProperties',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_transport_node(self, transport_node_id, **kwargs):  # noqa: E501
        """Refresh the node configuration for the Edge node.  # noqa: E501

        The API is applicable for Edge transport nodes. If you update the VM configuration and find a discrepancy in VM configuration at NSX Manager, then use this API to refresh configuration at NSX Manager. It refreshes the VM configuration from sources external to MP. Sources include vSphere Server and the edge node. After this action, the API GET api/v1/transport-nodes will show refreshed data.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_transport_node(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_transport_node_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.refresh_transport_node_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def refresh_transport_node_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Refresh the node configuration for the Edge node.  # noqa: E501

        The API is applicable for Edge transport nodes. If you update the VM configuration and find a discrepancy in VM configuration at NSX Manager, then use this API to refresh configuration at NSX Manager. It refreshes the VM configuration from sources external to MP. Sources include vSphere Server and the edge node. After this action, the API GET api/v1/transport-nodes will show refreshed data.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_transport_node_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `refresh_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}?action=refresh_node_configuration&resource_type=EdgeNode', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_transport_node_inventory_sync_restart_inventory_sync(self, transport_node_id, **kwargs):  # noqa: E501
        """Restart the inventory sync for the node if it is paused currently.  # noqa: E501

        Restart the inventory sync for the node if it is currently internally paused. After this action the next inventory sync coming from the node is processed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_transport_node_inventory_sync_restart_inventory_sync(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restart_transport_node_inventory_sync_restart_inventory_sync_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.restart_transport_node_inventory_sync_restart_inventory_sync_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def restart_transport_node_inventory_sync_restart_inventory_sync_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Restart the inventory sync for the node if it is paused currently.  # noqa: E501

        Restart the inventory sync for the node if it is currently internally paused. After this action the next inventory sync coming from the node is processed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_transport_node_inventory_sync_restart_inventory_sync_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_transport_node_inventory_sync_restart_inventory_sync" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `restart_transport_node_inventory_sync_restart_inventory_sync`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}?action=restart_inventory_sync', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_parent_cluster_configuration_restore_cluster_config(self, transport_node_id, **kwargs):  # noqa: E501
        """Apply cluster level Transport Node Profile on overridden host  # noqa: E501

        A host can be overridden to have different configuration than Transport Node Profile(TNP) on cluster. This action will restore such overridden host back to cluster level TNP.  This API can be used in other case. When TNP is applied to a cluster, if any validation fails (e.g. VMs running on host) then existing transport node (TN) is not updated. In that case after the issue is resolved manually (e.g. VMs powered off), you can call this API to update TN as per cluster level TNP.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_parent_cluster_configuration_restore_cluster_config(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_parent_cluster_configuration_restore_cluster_config_with_http_info(transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_parent_cluster_configuration_restore_cluster_config_with_http_info(transport_node_id, **kwargs)  # noqa: E501
            return data

    def restore_parent_cluster_configuration_restore_cluster_config_with_http_info(self, transport_node_id, **kwargs):  # noqa: E501
        """Apply cluster level Transport Node Profile on overridden host  # noqa: E501

        A host can be overridden to have different configuration than Transport Node Profile(TNP) on cluster. This action will restore such overridden host back to cluster level TNP.  This API can be used in other case. When TNP is applied to a cluster, if any validation fails (e.g. VMs running on host) then existing transport node (TN) is not updated. In that case after the issue is resolved manually (e.g. VMs powered off), you can call this API to update TN as per cluster level TNP.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_parent_cluster_configuration_restore_cluster_config_with_http_info(transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transport_node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_parent_cluster_configuration_restore_cluster_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `restore_parent_cluster_configuration_restore_cluster_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}?action=restore_cluster_config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resync_transport_node_resync_host_config(self, transportnode_id, **kwargs):  # noqa: E501
        """Resync a Transport Node  # noqa: E501

        Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resync_transport_node_resync_host_config(transportnode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transportnode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resync_transport_node_resync_host_config_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resync_transport_node_resync_host_config_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def resync_transport_node_resync_host_config_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Resync a Transport Node  # noqa: E501

        Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resync_transport_node_resync_host_config_with_http_info(transportnode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transportnode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resync_transport_node_resync_host_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `resync_transport_node_resync_host_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}?action=resync_host_config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_compute_collection_transport_node_template_and_tn_collection(self, body, template_id, **kwargs):  # noqa: E501
        """Update compute collection transportnode template  # noqa: E501

        Update configuration of compute collection transportnode template. Compute_collection_id isn't allowed to be changed since it represents the association between ComputeCollection and this template. This is determined when ComputeCollectionTransportNodeTemplate got created. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_compute_collection_transport_node_template_and_tn_collection(body, template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ComputeCollectionTransportNodeTemplate body: (required)
        :param str template_id: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_compute_collection_transport_node_template_and_tn_collection_with_http_info(body, template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_compute_collection_transport_node_template_and_tn_collection_with_http_info(body, template_id, **kwargs)  # noqa: E501
            return data

    def update_compute_collection_transport_node_template_and_tn_collection_with_http_info(self, body, template_id, **kwargs):  # noqa: E501
        """Update compute collection transportnode template  # noqa: E501

        Update configuration of compute collection transportnode template. Compute_collection_id isn't allowed to be changed since it represents the association between ComputeCollection and this template. This is determined when ComputeCollectionTransportNodeTemplate got created. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_compute_collection_transport_node_template_and_tn_collection_with_http_info(body, template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ComputeCollectionTransportNodeTemplate body: (required)
        :param str template_id: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_compute_collection_transport_node_template_and_tn_collection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_compute_collection_transport_node_template_and_tn_collection`")  # noqa: E501
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `update_compute_collection_transport_node_template_and_tn_collection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_network_migration_spec(self, body, template_id, **kwargs):  # noqa: E501
        """Update a template of network migration specification.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. For a HostProfileNetworkMigrationSpec which is already associated with a compute collection, updating it would mean next time the system needs to trigger migration for hosts managed by compute collection, it will use the updated migration specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_network_migration_spec(body, template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetworkMigrationSpec body: (required)
        :param str template_id: (required)
        :return: NetworkMigrationSpec
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_network_migration_spec_with_http_info(body, template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_network_migration_spec_with_http_info(body, template_id, **kwargs)  # noqa: E501
            return data

    def update_network_migration_spec_with_http_info(self, body, template_id, **kwargs):  # noqa: E501
        """Update a template of network migration specification.  # noqa: E501

        Network migration specification once created and can be used as a template to indicate associated component which networks should be migrated and where. Currently migration template can be associated with compute collections which are managed by vCenter host profiles, to trigger automatic migration of networks for Stateless ESX hosts. Currently we only support creation of HostProfileNetworkMigrationSpec type of specification. For a HostProfileNetworkMigrationSpec which is already associated with a compute collection, updating it would mean next time the system needs to trigger migration for hosts managed by compute collection, it will use the updated migration specification. Note- transport node templates APIs are deprecated and user is recommended to use transport node profiles APIs instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_network_migration_spec_with_http_info(body, template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NetworkMigrationSpec body: (required)
        :param str template_id: (required)
        :return: NetworkMigrationSpec
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_network_migration_spec" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_network_migration_spec`")  # noqa: E501
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `update_network_migration_spec`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-migration-specs/{template-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkMigrationSpec',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transport_node_maintenance_mode(self, transportnode_id, **kwargs):  # noqa: E501
        """Update transport node maintenance mode  # noqa: E501

        Put transport node into maintenance mode or exit from maintenance mode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transport_node_maintenance_mode(transportnode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transportnode_id: (required)
        :param str action:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_transport_node_maintenance_mode_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transport_node_maintenance_mode_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def update_transport_node_maintenance_mode_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Update transport node maintenance mode  # noqa: E501

        Put transport node into maintenance mode or exit from maintenance mode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transport_node_maintenance_mode_with_http_info(transportnode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transportnode_id: (required)
        :param str action:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transport_node_maintenance_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `update_transport_node_maintenance_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transport_node_with_deployment_info(self, body, transport_node_id, **kwargs):  # noqa: E501
        """Update a Transport Node  # noqa: E501

        Modifies the transport node information. The host_switch_name field must match the host_switch_name value specified in the transport zone (API: transport-zones). You must create the associated uplink profile (API: host-switch-profiles) before you can specify an uplink_name here. If the host is an ESX and has only one physical NIC being used by a vSphere standard switch, TransportNodeUpdateParameters should be used to migrate the management interface and the physical NIC into a logical switch that is in a transport zone this transport node will join or has already joined. If the migration is already done, TransportNodeUpdateParameters can also be used to migrate the management interface and the physical NIC back to a vSphere standard switch. In other cases, the TransportNodeUpdateParameters should NOT be used. When updating transport node you should follow pattern where you should fetch the existing transport node and then only modify the required properties keeping other properties as is. For API backward compatibility, property host_switches will be still returned in response and will contain the configuration matching the one in host_switch_spec. In update call you should only modify configuration in either host_switch_spec or host_switches, but not both. Property host_switch_spec should be preferred over deprecated host_switches property when creating or updating transport nodes.  It also modifies attributes of node (host or edge).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transport_node_with_deployment_info(body, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransportNode body: (required)
        :param str transport_node_id: (required)
        :param str esx_mgmt_if_migration_dest: The network ids to which the ESX vmk interfaces will be migrated
        :param str if_id: The ESX vmk interfaces to migrate
        :param str ping_ip: IP Addresses to ping right after ESX vmk interfaces were migrated.
        :param str vnic: The ESX vmk interfaces and/or VM NIC to migrate
        :param str vnic_migration_dest: The migration destinations of ESX vmk interfaces and/or VM NIC
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_transport_node_with_deployment_info_with_http_info(body, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transport_node_with_deployment_info_with_http_info(body, transport_node_id, **kwargs)  # noqa: E501
            return data

    def update_transport_node_with_deployment_info_with_http_info(self, body, transport_node_id, **kwargs):  # noqa: E501
        """Update a Transport Node  # noqa: E501

        Modifies the transport node information. The host_switch_name field must match the host_switch_name value specified in the transport zone (API: transport-zones). You must create the associated uplink profile (API: host-switch-profiles) before you can specify an uplink_name here. If the host is an ESX and has only one physical NIC being used by a vSphere standard switch, TransportNodeUpdateParameters should be used to migrate the management interface and the physical NIC into a logical switch that is in a transport zone this transport node will join or has already joined. If the migration is already done, TransportNodeUpdateParameters can also be used to migrate the management interface and the physical NIC back to a vSphere standard switch. In other cases, the TransportNodeUpdateParameters should NOT be used. When updating transport node you should follow pattern where you should fetch the existing transport node and then only modify the required properties keeping other properties as is. For API backward compatibility, property host_switches will be still returned in response and will contain the configuration matching the one in host_switch_spec. In update call you should only modify configuration in either host_switch_spec or host_switches, but not both. Property host_switch_spec should be preferred over deprecated host_switches property when creating or updating transport nodes.  It also modifies attributes of node (host or edge).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transport_node_with_deployment_info_with_http_info(body, transport_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransportNode body: (required)
        :param str transport_node_id: (required)
        :param str esx_mgmt_if_migration_dest: The network ids to which the ESX vmk interfaces will be migrated
        :param str if_id: The ESX vmk interfaces to migrate
        :param str ping_ip: IP Addresses to ping right after ESX vmk interfaces were migrated.
        :param str vnic: The ESX vmk interfaces and/or VM NIC to migrate
        :param str vnic_migration_dest: The migration destinations of ESX vmk interfaces and/or VM NIC
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'transport_node_id', 'esx_mgmt_if_migration_dest', 'if_id', 'ping_ip', 'vnic', 'vnic_migration_dest']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transport_node_with_deployment_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_transport_node_with_deployment_info`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `update_transport_node_with_deployment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transport_node_id' in params:
            path_params['transport-node-id'] = params['transport_node_id']  # noqa: E501

        query_params = []
        if 'esx_mgmt_if_migration_dest' in params:
            query_params.append(('esx_mgmt_if_migration_dest', params['esx_mgmt_if_migration_dest']))  # noqa: E501
        if 'if_id' in params:
            query_params.append(('if_id', params['if_id']))  # noqa: E501
        if 'ping_ip' in params:
            query_params.append(('ping_ip', params['ping_ip']))  # noqa: E501
        if 'vnic' in params:
            query_params.append(('vnic', params['vnic']))  # noqa: E501
        if 'vnic_migration_dest' in params:
            query_params.append(('vnic_migration_dest', params['vnic_migration_dest']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transport-node-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
